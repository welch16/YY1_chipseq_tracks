--- 
title: "NOTCH1 locus analysis"
author: "Rene Welch"
output:
  bookdown::html_document2:
    theme: spacelab
    fig_caption: true
    code_folding: hide
---

In the genome browser, we can see that there is a YY1 peak downstream, but some SPI1 and IKZF1 peaks upstream (or in the gene body) of NOTCH1.

```{r init, include = TRUE, echo = FALSE, eval = TRUE, out.width = "100%"}

knitr::include_url("https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr9%3A139367743%2D139464748&hgsid=878198357_Guoqn9ZhGzPpFaVJZfdx79zmiAPk", height = "700x")

```

```{r setup, echo = FALSE, include = FALSE, eval = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(
  include = TRUE,
  eval = TRUE,
  echo = TRUE,
  autodep = TRUE, fig.align = "center",
  message = FALSE, warning = FALSE, fig.ext = "png")

pacman::p_load(
  magrittr, tidyverse, GenomicRanges, cowplot, lme4)

theme_set(theme_bw() + theme(strip.background = element_blank()))

notch1_locus <-
  qs::qread(here::here("data", "qs", "notch1_locus.qs"))

peak_signal <-
  qs::qread(here::here("data", "qs", "notch1_peak_signals.qs"))

print_locus <- function(gr) {
  with(gr,
    glue::glue("{chr}:{start} - {end}",
    chr = seqnames,
    start =
      scales::comma(start, accuracy = .1, scale = 1e-6, suffix = "M"),
    end =
      scales::comma(end, accuracy = .1, scale = 1e-6, suffix = "M")))
}

peak_signal %<>%
  mutate(
    npeaks = map(data, select, peak) %>%
      map(distinct) %>% map_int(nrow))

```

We want to quantify whether that effect is statistically significant.

# NOTCH1 locus and data definition

For that purpose, we defined the NOTCH1 locus to be `r print_locus(notch1_locus)`. To perform statistical modelling, we had to extract a the signal from this locus, and parse the data into a matrix / vector form. Since the different tracks were downloaded from different experiments, and likely to be processed differently, we only consider the K562 cell line, since all those datasets were generated by the ENCODE consortium. Next, given a window size $w$ we build datasets by:

1. Extract peaks, by looking for the positions such that presented the highest signal in window of $w$ bps (to each side)
2. For every of this positions, search for the maximum signal value of every TF, in windows of $2w$ bps, centered around the peak summit.

```{r npeaks-plot, include = TRUE, echo = FALSE, eval = TRUE, out.width = 800, fig.width = 6, fig.height = 3, cache = TRUE}

ggplot(peak_signal, aes(windows, npeaks)) +
  geom_point(colour = "red", size = 3) +
  geom_line(colour = "red") +
  scale_x_continuous(labels = comma_format(1)) +
  labs(x = "window size", y = "# of peaks in NOTCH1 locus")

```

```{r estimate-models, include = TRUE, echo = FALSE, eval = TRUE}

clean_data <- function(data) {

  data %>%
    group_by(target) %>%
    mutate(
      max_signal = as.vector(scale(max_signal)),
      peak = fct_reorder(peak, start),
      target = factor(target))

}

peak_signal %<>%
  mutate(
    data = map(data, clean_data),
    lm_add = map(data, ~ lm(max_signal ~ target + peak, data = .)),
    aov_add = map(lm_add, anova))

pairs_plot <- function(data) {

  data %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(names_from = target, values_from = max_signal) %>%
    dplyr::select(-peak, -seqnames, -start, -end) %>%
    GGally::ggpairs()

}

```

# Correlations between TF {.tabset .tabset-fade}

Following an elbow criteia, we determine that the appropiate window size would be either 1K or 2K bps, since is at those values where the number of peaks in the NOTCH1 locus becomes more stable.

## window 1K {-#window-1K}

```{r scater-1K, include = TRUE, echo = FALSE, eval = TRUE, fig.width = 6, fig.height = 6, out.width = "80%"}

pairs_plot(peak_signal$data[[4]])

```

## window 2K {-#window-2K}

```{r scater-2K, include = TRUE, echo = FALSE, eval = TRUE, fig.width = 6, fig.height = 6, out.width = "80%"}

pairs_plot(peak_signal$data[[5]])

```

# Statistical models {.tabset .tabset-fade}

In this setting, we don't have replicates for any TF, therefore it is imposible to estimate interation effects. Being said that we can model the signal as the sum of a location and a TF effects. Let $i=1,2,\cdots, n$ be the TFs in the dataset, and $j=1,\cdots,m $ be the different peak locations. Then, we define:

$$
\begin{aligned}
y_{ij} = \mu + \alpha_i + \beta_j +  \epsilon_{ij}
\end{aligned}
$$

where:

- $y_{ij}$ is the signal at the peak summit $j$ of TF $i$
- $\mu$ is the average signal effect
- $\alpha_i$ is the average signal effect for TF $i$
- $\beta_j$ is the average signal effect at location $j$

If we do an ANOVA analysis for those two window sizes we can notice, that in both cases there is a significant location effect, but not a TF effect. This is not surprsing, as the TF peaks are specific to few locations. On the other hand, by design we are picking locations in the genome with a peak for one of the TFs of interest, so it is expected to not see a TF effect, since there is no TF with peaks at almost all locations. Finally, for this analysis we only utilized one track per TF, so unfortunately is impossible to estimate any interaction effects, perhaps if we had biological replicates it will be possible.

```{r anova-tables, echo = FALSE}

clean_table <- function(x) {

  mutate(x,
    term = case_when(
      term == "target" ~ "TF",
      term == "peak" ~ "location",
      TRUE ~ term),
    sumsq = scales::comma(sumsq, .01),
    meansq = round(meansq, 2),
    statistic = if_else(is.na(statistic), "",
      as.character(round(statistic, 4))),
    p.value = if_else(is.na(p.value), "", scales::scientific(p.value)))

}

tables <- peak_signal %>%
  dplyr::slice(4:5) %>% pull(aov_add) %>%
  map(broom::tidy) %>%
  map(clean_table) %>%
  map(knitr::kable)

```

## anova-1K {-#anova-1k}

```{r anova-1Kw, include = TRUE, echo = FALSE, eval = TRUE}

tables[[1]]

```

## anova-2K {-#anova-2k}

```{r anova-2Kw, include = TRUE, echo = FALSE, eval = TRUE}

tables[[2]]

```